<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GT-IRB: GTIRB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GT-IRB
   &#160;<span id="projectnumber">v0.0</span>
   </div>
   <div id="projectbrief">GrammaTech Intermediate Representation for Binaries</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GTIRB </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="gtirb"></a></p>
<p>The GrammaTech Intermediate Representation for Binaries (GTIRB) is a machine code analysis and rewriting data structure. It is intended to facilitate the communication of binary IR between programs performing binary disassembly, analysis, transformation, and pretty printing. GTIRB is modeled on LLVM-IR, and seeks to serve a similar functionality of encouraging communication and interoperability between tools.</p>
<p>The remainder of this file has information on GTIRB's:</p><ul>
<li><a href="#structure">Structure</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
<h2>Structure</h2>
<p><a class="anchor" id="structure"></a></p>
<p>GTIRB has the following structure: </p><pre class="fragment">  Aux Data
  /
IR        -----Data---Bytes
  \      /-----Symbols
  Modules------SymbolicExpressions
         \-----ImageByteMap
          -----ICFG
               /  \
          Blocks  Edges
             |
        Instructions---Bytes
</pre><h3>IR</h3>
<p><a class="anchor" id="ir"></a></p>
<p>An instance of GTIRB may include multiple <code>module</code>s which represent loadable objects such as executables or libraries. Each <code>module</code> holds information such as <code>symbol</code>s, <code>data</code>, and an inter-procedural control flow graph (<code>ICFG</code>). The <code>ICFG</code> consists of basic <code>block</code>s and control flow edges between these <code>block</code>s. Each <code>block</code> holds some number of <code>instruction</code>s. Each <code>datum</code> and <code>instruction</code> holds both a pointer to a range of bytes in the <code>ImageByteMap</code> and <code>symbolic</code> information coverage that range.</p>
<h3>Instructions</h3>
<p><a class="anchor" id="instructions"></a></p>
<p>GTIRB explicitly does NOT represent instructions but does provide symbolic operand information and access to the bytes. There are many options for representation of single instructions (e.g., <a href="https://github.com/BinaryAnalysisPlatform/bap">BAP</a>'s <a href="https://github.com/BinaryAnalysisPlatform/bil/releases/download/v0.1/bil.pdf">BIL</a>, or <a href="http://angr.io">Angr</a>'s <a href="https://github.com/angr/pyvex">Vex</a>). Instruction bytes may easily be decoded/encoded using the popular <a href="https://www.capstone-engine.org">Capstone</a>/<a href="https://www.keystone-engine.org">Keystone</a> disassembler/assembler.</p>
<h3>Auxiliary Data</h3>
<p><a class="anchor" id="auxiliary-data"></a></p>
<p>Additional arbitrary information, e.g. analysis results, may be added to GTIRB in the form of <code>AuxData</code> object. These can store maps and vectors of basic GTIRB types in a portable way. This repository will describe the anticipated structure for very common auxiliary data.</p>
<h3>UUIDs</h3>
<p><a class="anchor" id="uuids"></a></p>
<p>Every element of GTIRB (namely: modules (<code>Module</code>), symbols (<code>Symbol</code>), globals, blocks (<code>Block</code>), and instructions (<code>InstructionRef</code>) has a unique associated ID.</p>
<h2>Building</h2>
<p><a class="anchor" id="building"></a></p>
<p>GTIRB should successfully build in 64-bits with GCC, Clang, and Visual Studio compilers supporting at least C++17. GTIRB uses CMake which must be installed.</p>
<div class="fragment"><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ../path/to/gtirb</div><div class="line">make -j</div><div class="line"># Run the test suite.</div><div class="line">&lt;a name=&quot;run-the-test-suite.&quot; id=&quot;run-the-test-suite.&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">./bin/TestGTIRB</div></div><!-- fragment --><h2>Usage</h2>
<p><a class="anchor" id="usage"></a></p>
<p>GTIRB is designed to be serialized using <a href="https://developers.google.com/protocol-buffers/">Google's protocol Buffers</a> (i.e., <a href="https://github.com/google/protobuf/wiki">protobuf</a>) and eventually JSON through protobuf's JSON output, enabling easy use from any programming language. GTIRB may also be used as a C++ library implementing an efficient data structure suitable for use by binary analysis and rewriting applications.</p>
<p>This repository defines the GTIRB data structure and C++ library.</p>
<h3>Populating the IR</h3>
<p><a class="anchor" id="populating-the-ir"></a></p>
<p>GT-IRB objects are created within a <code>Context</code> object. Freeing the <code>Context</code> will also destroy all the objects within it.</p>
<div class="fragment"><div class="line">Context C;</div><div class="line">IR&amp; ir = *IR::Create(C);</div></div><!-- fragment --><p>Every IR holds a set of modules.</p>
<div class="fragment"><div class="line">ir.addModule(Module::Create(C));</div><div class="line">Module&amp; module = ir.modules()[0];</div></div><!-- fragment --><p>Addresses are represented by a distinct type which can be explicitly converted to and from <code>uint64_t</code>.</p>
<div class="fragment"><div class="line">Addr textSectionAddress(1328);</div></div><!-- fragment --><p>Create some sections: </p><div class="fragment"><div class="line">module.addSection(Section::Create(C, <span class="stringliteral">&quot;.text&quot;</span>, textSectionAddress, 466));</div><div class="line">module.addSection(</div><div class="line">    Section::Create(C, <span class="stringliteral">&quot;.data&quot;</span>, textSectionAddress + 466, 2048));</div></div><!-- fragment --><p>Create some data objects. These only define the layout and do not directly store any data.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>* data1 = DataObject::Create(C, Addr(2608), 6);</div><div class="line"><span class="keyword">auto</span>* data2 = DataObject::Create(C, Addr(2614), 2);</div><div class="line">module.addData(data1);</div><div class="line">module.addData(data2);</div></div><!-- fragment --><p>The actual data is stored in the module's ImageByteMap:</p>
<div class="fragment"><div class="line">ImageByteMap&amp; byteMap = module.getImageByteMap();</div><div class="line">byteMap.setAddrMinMax({Addr(2608), Addr(2616)});</div><div class="line">std::array&lt;uint8_t, 8&gt; bytes{1, 0, 2, 0, 115, 116, 114, 108};</div><div class="line">byteMap.setData(Addr(2608), bytes);</div></div><!-- fragment --><p>Symbols associate a name with an object in the <code>IR</code>, such as a <code>DataObject</code> or <code>Block</code>. They can optionally store an address as well.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> data = module.data();</div><div class="line">module.addSymbol(Symbol::Create(C,</div><div class="line">                                Addr(2608), <span class="comment">// address</span></div><div class="line">                                <span class="stringliteral">&quot;data1&quot;</span>,    <span class="comment">// name</span></div><div class="line">                                data1,      <span class="comment">// referent</span></div><div class="line">                                Symbol::StorageKind::Extern));</div><div class="line">module.addSymbol(Symbol::Create(C, Addr(2614), <span class="stringliteral">&quot;data2&quot;</span>, data2,</div><div class="line">                                Symbol::StorageKind::Extern));</div></div><!-- fragment --><p>GTIRB can store multiple symbols with the same address.</p>
<div class="fragment"><div class="line">module.addSymbol(Symbol::Create(C, Addr(2614), <span class="stringliteral">&quot;duplicate&quot;</span>, data2,</div><div class="line">                                Symbol::StorageKind::Local));</div></div><!-- fragment --><p>Basic blocks are stored in an interprocedural CFG. Like <code>DataObjects</code>, <code>Blocks</code> reference data in the <code>ImageByteMap</code> but do not directly hold any data themselves. GTIRB does not directly represent instructions.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; cfg = module.getCFG();</div><div class="line"><span class="keyword">auto</span>* b1 = <a class="code" href="group___c_f_g___g_r_o_u_p.html#ga81d9eddcc97ebdb8e4ccb8c011c7e3c2">emplaceBlock</a>(cfg, C, Addr(466), 6);</div><div class="line"><span class="keyword">auto</span>* b2 = <a class="code" href="group___c_f_g___g_r_o_u_p.html#ga81d9eddcc97ebdb8e4ccb8c011c7e3c2">emplaceBlock</a>(cfg, C, Addr(472), 8);</div></div><!-- fragment --><p>The <code>CFG</code> can be populated with edges to denote control flow. Or edges can be omitted and the <code>CFG</code> used simply as a container for <code>Blocks</code>..</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> edge1 add_edge(vertex1, vertex2, mainModule.getCFG()).first;</div></div><!-- fragment --><p>Edges can have boolean or numeric labels:</p>
<div class="fragment"><div class="line">module.getCFG()[edge1] = <span class="keyword">true</span>;</div><div class="line">module.getCFG()[edge2] = 1;</div></div><!-- fragment --><p>Information on symbolic operands and data is indexed by address:</p>
<div class="fragment"><div class="line">Symbol* dataSym = &amp;*module.findSymbols(Addr(2614)).begin();</div><div class="line">module.addSymbolicExpression(Addr(472), SymAddrConst{0, dataSym});</div></div><!-- fragment --><p>Finally, auxiliary data can be used to store additional data at the IR level. An <code>AuxData</code> object can store integers, strings, basic GTIRB types such as <code>Addr</code> and <code>UUID</code>, and tuples or containers over these types.</p>
<div class="fragment"><div class="line">ir.addAuxData(<span class="stringliteral">&quot;addrTable&quot;</span>, std::vector&lt;Addr&gt;({Addr(1), Addr(2), Addr(3)}));</div><div class="line">ir.addAuxData(<span class="stringliteral">&quot;stringMap&quot;</span>, std::map&lt;std::string, std::string&gt;(</div><div class="line">                             {{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;str1&quot;</span>}, {<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;str2&quot;</span>}}));</div></div><!-- fragment --><h3>Querying the IR</h3>
<p><a class="anchor" id="querying-the-ir"></a></p>
<p>Symbols can be looked up by address or name. Any number of symbols can share an address or name, so be prepared to deal with multiple results.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> syms = module.findSymbols(Addr(2614));</div><div class="line"><span class="keyword">auto</span> it = syms.begin();</div><div class="line">Symbol&amp; sym1 = *it++;</div><div class="line">assert(sym1.getName() == <span class="stringliteral">&quot;data2&quot;</span>);</div><div class="line">assert((*it++).getName() == <span class="stringliteral">&quot;duplicate&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span>&amp; sym2 = *module.findSymbols(<span class="stringliteral">&quot;data1&quot;</span>).begin();</div><div class="line">assert(sym2.getAddress() == Addr(2608));</div></div><!-- fragment --><p>Use a symbol's referent (either an InstructionRef or DataObject) to get more information about the object to which the symbol points.</p>
<div class="fragment"><div class="line">DataObject* referent = sym1.getReferent&lt;DataObject&gt;();</div><div class="line">assert(referent);</div><div class="line">assert(referent-&gt;getAddress() == Addr(2614));</div><div class="line">assert(referent-&gt;getSize() == 2);</div></div><!-- fragment --><p>The CFG uses <a href="https://www.boost.org/doc/libs/1_67_0/libs/graph/doc/">boost::graph</a>. GTIRB also provides a convenience function for iterating over blocks:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; b : <a class="code" href="group___c_f_g___g_r_o_u_p.html#ga5039337a49b78d1fe67d47a61f8fcba9">blocks</a>(cfg)) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Block: &quot;</span> &lt;&lt; uint64_t(b.getAddress()) &lt;&lt; <span class="stringliteral">&quot;..&quot;</span></div><div class="line">            &lt;&lt; uint64_t(<a class="code" href="classgtirb_1_1_addr.html#a94b7fd934eae65c03b284cc50d352030">addressLimit</a>(b)) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><code>Blocks</code> contain a <code>vertex_descriptor</code> which is used to look up corresponding information in the <code>CFG</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [edgeDescriptor, exists] = edge(b1-&gt;getVertex(), b2-&gt;getVertex(), cfg);</div><div class="line">assert(exists);</div></div><!-- fragment --><p><code>edge_descriptors</code> can be used to look up labels and the source/target blocks:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> edgeRange = edges(cfg);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = edgeRange.first; it != edgeRange.second; it++) {</div><div class="line">  <span class="keyword">auto</span> e = *it;</div><div class="line">  <span class="keyword">auto</span> v1 = source(e, cfg);</div><div class="line">  <span class="keyword">auto</span> v2 = target(e, cfg);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Edge: &quot;</span> &lt;&lt; uint64_t(cfg[v1]-&gt;getAddress()) &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span></div><div class="line">            &lt;&lt; uint64_t(cfg[v2]-&gt;getAddress());</div><div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span>* b = std::get_if&lt;bool&gt;(&amp;cfg[e])) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; *b;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Data have to be resolved to the correct type with the <code>get()</code> method before use. This will return null if the wrong type is requested.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> addrTable = ir.getAuxData(<span class="stringliteral">&quot;addrTable&quot;</span>)-&gt;get&lt;std::vector&lt;Addr&gt;&gt;();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> addr : *addrTable) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Addr: &quot;</span> &lt;&lt; uint64_t(addr) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">auto</span>* stringMap =</div><div class="line">    ir.getAuxData(<span class="stringliteral">&quot;stringMap&quot;</span>)-&gt;get&lt;std::map&lt;std::string, std::string&gt;&gt;();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> p : *stringMap) {</div><div class="line">  std::cout &lt;&lt; p.first &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><h3>Serialization</h3>
<p><a class="anchor" id="serialization"></a></p>
<p>Serialize IR to a file:</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;path/to/file&quot;</span>);</div><div class="line">ir.save(out);</div></div><!-- fragment --><p>Deserialize from a file:</p>
<div class="fragment"><div class="line">std::ifstream in(<span class="stringliteral">&quot;path/to/file&quot;</span>);</div><div class="line">IR&amp; newIR = *IR::load(C, in);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
